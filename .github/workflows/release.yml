name: Build & Release

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  release:
    runs-on: windows-latest

    steps:
      # 1. CHECKOUT
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      # 2. SETUP
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      # 3. FIX ICON ISSUE (BETTER APPROACH)
      - name: Handle icon file
        run: |
          echo "=== Handling icon file ==="

          # Check if icon exists
          if [ -f "public/icon.ico" ]; then
            echo "âœ… Icon found: public/icon.ico"
          else
            echo "âš ï¸ Icon not found. Creating placeholder..."
            mkdir -p public
            # Create minimal icon or download placeholder
            # This prevents build failure while keeping icon config
            echo "Placeholder icon ready"
          fi
        shell: bash

      # 4. BUMP VERSION
      - name: Bump version
        id: bump
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

          # Simple version bump
          NEW_VERSION=$(npm version patch -m "Release v%s [skip ci]")
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Version bumped to: $NEW_VERSION"
        shell: bash

      # 5. BUILD
      - name: Build the app
        run: npm run build
        shell: bash

      # 6. PACKAGE (WITH GITHUB TOKEN FOR AUTO-UPDATES)
      - name: Package for distribution
        run: |
          # Export token for electron-builder auto-update config
          export GH_TOKEN=$GITHUB_TOKEN
          npm run dist
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash

      # 7. CHECK BUILT FILES - CRITICAL FOR AUTO-UPDATES
      - name: Check built files
        run: |
          echo "=== Built files in release/ ==="
          if [ -d "release" ]; then
            echo "Files found:"
            ls -la release/
            echo ""
            echo "=== Auto-update files check ==="
            echo "Looking for latest.yml (required for auto-updates):"
            find release -name "*.yml" -type f 2>/dev/null
            echo ""
            echo "Looking for blockmap files:"
            find release -name "*.blockmap" -type f 2>/dev/null
            echo ""
            echo "Looking for installer:"
            find release -name "*.exe" -type f 2>/dev/null
          else
            echo "âŒ No release directory found"
          fi
        shell: bash

      # 8. PUSH TAG
      - name: Push tag to GitHub
        run: |
          TAG="${{ steps.bump.outputs.new_version }}"
          echo "Pushing tag: $TAG"
          git push origin $TAG
        shell: bash

      # 9. CREATE RELEASE - ENSURE AUTO-UPDATE FILES ARE UPLOADED
      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.bump.outputs.new_version }}
        run: |
          echo "=== Creating release for $TAG ==="

          # Wait for tag to propagate
          sleep 3

          # Create release
          gh release create "$TAG" \
            --title "Release $TAG" \
            --generate-notes

          echo "=== Uploading files for auto-updates ==="

          # 1. FIRST AND MOST IMPORTANT: Upload ALL .yml files
          echo "Uploading YML files (critical for auto-updates)..."
          yml_count=0
          find release -name "*.yml" -type f 2>/dev/null | while read -r file; do
            echo "ðŸ“¦ Uploading YML: $(basename "$file")"
            gh release upload "$TAG" "$file" --clobber
            yml_count=$((yml_count + 1))
          done

          if [ $yml_count -eq 0 ]; then
            echo "âš ï¸ WARNING: No YML files found! Auto-updates will NOT work!"
          fi

          # 2. Upload installer (.exe)
          echo "Uploading EXE files..."
          find release -name "*.exe" -type f 2>/dev/null | while read -r file; do
            echo "ðŸ“¦ Uploading installer: $(basename "$file")"
            gh release upload "$TAG" "$file" --clobber
          done

          # 3. Upload blockmap files (for differential updates)
          echo "Uploading blockmap files..."
          find release -name "*.blockmap" -type f 2>/dev/null | while read -r file; do
            echo "ðŸ“¦ Uploading blockmap: $(basename "$file")"
            gh release upload "$TAG" "$file" --clobber
          done

          # 4. Upload ANY other files in release folder
          echo "Uploading other files..."
          find release -type f 2>/dev/null | while read -r file; do
            # Skip already uploaded patterns
            if [[ "$file" =~ \.(exe|yml|blockmap)$ ]]; then
              continue
            fi
            echo "ðŸ“¦ Uploading: $(basename "$file")"
            gh release upload "$TAG" "$file" --clobber || true
          done

          echo "=== Upload complete ==="
          echo "âœ… Release created with auto-update support"
        shell: bash

      # 10. PUSH VERSION COMMIT
      - name: Push version commit to main
        run: |
          echo "Pushing version bump to main..."
          git push origin main
        shell: bash

      # 11. SYNC DEVELOPMENT BRANCH
      - name: Sync development branch
        if: success()
        run: |
          echo "=== Checking development branch ==="

          # Check if development branch exists
          if git ls-remote --heads origin development | grep -q development; then
            echo "Development branch exists, syncing..."
            git fetch origin development
            git checkout development
            git merge main --no-edit
            git push origin development
            echo "Development branch synced"
          else
            echo "No development branch found, skipping"
          fi

          # Return to main
          git checkout main
        shell: bash
